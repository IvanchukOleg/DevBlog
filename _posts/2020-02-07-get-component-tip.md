---
layout: post
title:  "GetComponent vs TryGetComponent та особливості оператора \"==\" для GameObject"
visible: 1
categories: [Unity]
tags: [unity, editor, profiler, c#, tip]
author: Matanist
---

* content
{:toc}

## Оновлення Unity
Читаючи про те, що нового додалося в Unity 2019.3.0 зустрів рядок:  
**Scripting: Added: Add the TryGetComponent API to GameObject and Component classes that do not allocate in the editor when the component does not exist**  
Щоб зрозуміти, що це таке і нащо воно треба, довелося розібратись із особливостями реалізації об’єктів, що наслідуються від UnityEngine.Object, зокрема GameObject, а також тим, як реалізується оператор ```==``` для цих об’єктів.





## Особливості реалізації оператора ```==``` в Unity  
Виявляється, що для об’єктів, які наслідуються від UnityEngine.Object є власна реалізація оператора ```==```.  
Зроблено це із декількох причин.
1. Коли MonoBehaviour має якісь поля, то в редакторі (***лише*** в редакторі) ці поля ніколи не будуть *дійсно рівні* ```null```. Вони матимуть значення "фальшивого" ```null```.
Це потрібно для того, щоб отримували більше контекстної інформації при зверненні до об’єкта (або будь-якого із його полів), який мав би бути рівний ```null```.  
Без цього специфічного "костиля" не вдалося б з’ясувати, який саме GameObject мав цей MonoBehaviour і яке поле було (або мало б бути) рівним ```null```.
2. Друга причина трохи складніша:  
Оскільки Unity — це двіжок, написаний на C/C++, більшість фактичної інформації про конкретний GameObject (ім’я, список компонентів, тощо), як і про все, що наслідується від UnityEngine.Object, зберігається на стороні C++.
Тому об’єкт C# — це, по суті, обгортка над C++ частиною цього об’єкта. Час існування C++ частини об’єктів контролюється явно. Ці об’єкти знищуються при завантаженні нової сцени, або при виклику ```Destroy(myObject);```.
Час існування C# обгортки об’єктів контролюється неявно, зокрема через garbage collector. Це означає, що можлива ситуація, коли C++ об’єкта вже фактично немає, а C# обгортка досі існує і посилається на знищений C++ об’єкт.
При виконанні перевірки ```myObject == null``` повернеться true, навіть якщо фактично C# змінна не рівна ```null``` *насправді*.  


## Недоліки перевантаженого оператора ```==```
* це не інтуїтивно;
* порівняння двох UnityEngine.Object між собою або перевірка на рівність ```null``` може бути значно повільнішою, ніж очікується;
* перевантажений оператор ```==``` не є потокобезпечним *(примітка: можливо, це вже поправили, бо взято зі статті 2014 року. А може і не поправили.)*;
* перевантажений оператор ```==``` працює за принципом, відмінним від ```??```, оскільки оператор ```??``` не може бути перевантаженим. Тобто оператор ```??``` використовує "чисту" перевірку на рівність null C# обгортки.

## До чого це все
Починаючи із Unity 2019.2 замість того, щоб спочатку викликати ```GetComponent```, а тоді превіряти на рівність ```null```  
```c#
SpriteRenderer spriteRenderer = GetComponent<SpriteRenderer>();
if (spriteRenderer == null)
{
    spriteRenderer.color = _myColor;
}
```
можна використовувати ```TryGetComponent```:
```c#
if (TryGetComponent<SpriteRenderer>(out SpriteRenderer spriteRenderer))
{
    spriteRenderer.color = _myColor;
}
```
На відміну від старого варіанту, при використанні TryGetComponent в редакторі не виділяється пам’ять на створення допоміжного об’єкта, рівного "фальшивому" ```null```.

## Підсумок
* З точки зору продуктивності/економії пам’яті є доцільність використання ```TryGetComponent``` ***лише*** в редакторі, оскільки тоді показники в profiler при запуску гри в редакторі будуть ближчими до реальних показників після збірки.
* Використання ```TryGetComponent``` спрощує процес написання коду, оскільки зменшує конструкцію аж на один рядочок :)
* Треба ще детальніше протестувати в профайлері, чи є якась принципова різниця в продуктивності. Швидше за все, немає, оскільки, думаю, "під капотом" використовується все той же перевантажений оператор ```==```, але потрібно перевірити.

## Корисні посилання:
* [chenjd.xyz blog](https://medium.com/chenjd-xyz/unity-tip-use-trygetcomponent-instead-of-getcomponent-to-avoid-memory-allocation-in-the-editor-fe0c3121daf6 "Стаття, з якої взяв детальнішу інформацію")  
* [Unity Blog, 2014.05.16](https://blogs.unity3d.com/2014/05/16/custom-operator-should-we-keep-it/ "Стара стаття із описом особливостей оператора \"==\" для GameObject")